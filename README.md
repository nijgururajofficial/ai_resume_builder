# AI Resume Builder with Google Gemini & LangGraph 🚀

[![Python Version](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Project Status](https://img.shields.io/badge/status-active-brightgreen.svg)]()

An intelligent system that generates highly tailored, ATS-compliant resumes by leveraging the power of **Google's Gemini Pro**, orchestrated by **LangGraph**. This tool transforms a generic user profile into a professional resume customized for a specific job description, significantly increasing the chances of passing through automated screening systems.

***

## Table of Contents

* [How It Works: The Agentic Workflow](#how-it-works-the-agentic-workflow)
* [Core Features](#core-features)
* [Technology Stack](#technology-stack)
* [Project Structure](#project-structure)
* [Setup and Installation](#setup-and-installation)
* [Usage](#usage)
* [Running Tests](#running-tests)

---

## How It Works: The Agentic Workflow

The application follows a modular, agent-based workflow managed by LangGraph. This ensures a clear separation of concerns and a predictable, stateful process. The system receives a user profile and a job description, then processes them through a sequence of specialized agents to produce the final resume.

1.  **🤖 `JobDescriptionAnalysisAgent`**: This first agent receives the raw job description. It uses the Gemini API to perform a detailed analysis, extracting the precise **job title**, required **skills** (including important acronyms), and key **responsibilities**.

2.  **✍️ `ResumeContentSelectionAgent`**: Using the insights from the first agent, this agent selects the most relevant experiences and projects from the user's master profile. It then prompts the Gemini API to rewrite this content, strategically weaving in keywords and quantifying achievements to align perfectly with the job requirements.

3.  **📝 `MarkdownFormattingAgent`**: This is a deterministic agent that takes the tailored content generated by the previous agent and assembles it into a clean, well-structured, and ATS-compliant Markdown format.

4.  **📄 `PdfDocxGenerator`**: Finally, this utility converts the formatted Markdown into two professional outputs: a `.docx` file for easy editing and a visually styled `.pdf` file, ensuring perfect fonts, spacing, and layout for submission.

---

## Core Features

* **✨ AI-Powered Tailoring**: Uses the Google Gemini API to analyze job descriptions and strategically rewrite resume content to match required skills and responsibilities.
* **✅ ATS Optimization**: Strictly adheres to Universal ATS Resume Requirements, ensuring maximum compatibility with systems like Oracle Taleo, Workday, and iCIMS.
* **🧠 Agentic Workflow**: Employs a multi-agent architecture with LangGraph for a robust, debuggable, and transparent pipeline (Analyze → Select → Format → Generate).
* **📊 Quantified Achievements**: Intelligently highlights and prioritizes measurable results and metrics from the user's profile to demonstrate impact.
* **📄 Dual Format Output**: Generates resumes in both `.docx` and visually styled `.pdf` formats, ready for any application platform.
* **🔒 Secure & Configurable**: Manages API keys via environment variables and user data via a simple JSON profile.

---

## Technology Stack

* **Backend**: Python 3.9+
* **AI/LLM**: Google Gemini Pro
* **Agent Framework**: LangGraph
* **Dependencies**: `google-generativeai`, `langchain`, `python-docx`, `markdown-pdf`

---

## Project Structure

```
ai_resume_builder/
├── agents/                 # Contains the specialized AI agents
├── core/                   # Core services: Gemini client, orchestrator, document generator
├── data/                   # Stores the user's master profile
│   └── user_profile.json
├── output/                 # Default directory for generated resumes
├── temp/                   # Stores intermediate outputs for debugging
├── tests/                  # Unit tests for the system
├── .env                    # For storing secret API keys
├── main.py                 # Main application entrypoint (CLI)
├── requirements.txt        # Project dependencies
└── README.md               # This file
```

---

## Setup and Installation

Follow these steps to set up and run the project locally.

### 1. Clone the Repository

```sh
git clone https://github.com/nijgururajofficial/ai_resume_builder.git
cd ai-resume-builder
```

### 2. Create and Activate a Virtual Environment

* **macOS / Linux**:
    ```sh
    python3 -m venv venv
    source venv/bin/activate
    ```
* **Windows**:
    ```powershell
    python -m venv venv
    .\venv\Scripts\Activate.ps1
    ```

### 3. Install Dependencies

Install all the required Python libraries using `pip`.

```sh
pip install -r requirements.txt
```

### 4. Set Up Environment Variables

Create a file named `.env` in the project's root directory. Get your API key from **[Google AI Studio](https://aistudio.google.com/)** and add it to this file.

```env
# .env
GEMINI_API_KEY="YOUR_GOOGLE_API_KEY_HERE"
```

### 5. Configure Your Profile

Edit the `data/user_profile.json` file to contain your personal information, work experience, education, skills, and projects. Follow the existing JSON structure carefully.

---

## Usage

The application is run from the command line. You must provide a path to a plain text file containing the job description you are targeting.

### Example

1.  Save a job description into a file (e.g., `job_desc.txt`).
2.  Run the `main.py` script from the root directory:

    ```sh
    python main.py --job-desc path/to/your/job_desc.txt
    ```

The script will execute the full pipeline and save the generated `.docx` and `.pdf` resumes into the `output/` directory.

### Command-Line Arguments

* `--job-desc`: **(Required)** Path to the text file containing the job description.
* `--profile`: (Optional) Path to your user profile JSON file. Defaults to `data/user_profile.json`.
* `--output-dir`: (Optional) Directory to save the generated resumes. Defaults to `output/`.

---

## Running Tests

To ensure all components are working correctly, you can run the built-in unit tests. The tests use mock objects to validate the agents' logic without making actual API calls.

```sh
python -m unittest discover tests
